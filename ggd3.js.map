{"version":3,"sources":["index.js","configure.js","mapData.js","draw.js","export.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ggd3.js","sourcesContent":["// Configure for Node and the browser.\nvar isNode = false;\nif (typeof module !== 'undefined' && module.exports) {\n  var d3    = require('d3');\n  var _     = require('underscore');\n  var async = require('async');\n\n  // Uses jsdom to build HTML server side.\n  isNode   = true;Â \n  document = require('jsdom').jsdom();\n  window   = document.parentWindow;\n}\n\nif (!d3 || !_ || !async) { throw 'ggd3 requires D3, Async, and Underscore.'; }\n\n\nvar ggd3 = {};\nggd3.VERSION = '0.0.0';\n\n\nvar Graphic = function() {\n  this.el = d3.select(document.createElement('div'));\n  this.stats = {};\n  this.data = [];\n  this.applyData = function(data) { this.data = data; }\n};\n\n\nggd3.create = function(spec, data) {\n  var graphic = new Graphic();\n  graphic.configure(spec);\n  graphic.analyzeData();\n  graphic.mapData();\n\n  // If the graphic's dimensions were specified\n  // or if they can be retrieved from \"el\", go\n  // ahead and call graphic.draw.\n\n  var el     = graphic.spec.el;\n  var width  = graphic.spec.width;\n  var height = graphic.spec.height;\n\n  var hasDimensions = el || (height && width);\n  if (hasDimensions) { graphic.draw(el, width, height); }\n\n  return graphic;\n};","ggd3.defaults = {\n\n  // Display a title above the chart.\n  title: undefined,\n\n  // Selector for destination graphic.\n  el: undefined,\n\n  // Draw a graphic of these dimensions, else inherit from el.\n  width: undefined,\n  height: undefined,\n\n  // Map column names to attributes/components.\n  x: undefined,\n  y: undefined,\n  color: undefined,\n  size: undefined,\n  facet: undefined,\n  facetX: undefined,\n  facetY: undefined,\n\n  // Geoms may be point, line, or bar (more to come).\n  geometry: 'point',\n\n  // If true, each facet will scale its x-axis independently.\n  floatFacetScaleX: false,\n  floatFacetScaleY: false,\n\n  // Datatypes may be string, number, or time.\n  xType: undefined,\n  yType: undefined,\n  colorType: undefined,\n  sizeType: undefined,\n  facetType: undefined,\n  facetXType: undefined,\n  facetYType: undefined\n};\n\n\nGraphic.prototype.configure = function(spec, done) {\n  this.spec = _.defaults(spec || {}, ggd3.defaults)\n  if (done) { done(); }\n};","// Map Data to Components.\nGraphic.prototype.mapData = function(done) {\n  this.yFacets    = [];\n  this.xFacets    = [];\n  this.facets     = [];\n  this.groups     = [];\n  this.geometries = [];\n\n  mapYFacets.call(this, this.data, function() { if (done) { done(); } });\n};\n\n\n// Like an SQL group by, D3's nest organizes the given\n// dataset by key. Each group is sent to iterator.\nfunction nest(data, key, iterator, done) {\n  var nestedData = d3.nest()\n    .key(function(row) { return row[key]; })\n    .entries(data)\n\n  // Apply iterator to each group, then callback with nestedData.\n  async.each(nestedData, iterator, function() { done(nestedData); });\n}\n\n\nfunction mapYFacets(data, done) {\n  var that = this;\n  var key  = this.spec.facetY;\n\n  nest(data, key, function(nested, cb) {\n    var yFacet = { key: key, value: nested.key };\n    if (nested.key !== 'undefined') { that.yFacets.push(yFacet); }\n    mapXFacets.call(that, nested.values, cb);\n  },\n\n  // After nest completes, calculate stats.\n  function() {\n    if (mapYFacets.length > 0) {\n      that.stats.extent = d3.extent()\n    }\n    done();\n  });\n}\n\n\nfunction mapXFacets(data, done) {\n  var that = this;\n  var key  = this.spec.facetX;\n\n  nest(data, key, function(nested, cb) {\n    var xFacet = { key: key, value: nested.key };\n    if (nested.key !== 'undefined') { that.xFacets.push(xFacet); }\n    mapFlowFacets.call(that, nested.values, cb);\n  }, \n  done);\n}\n\n\nfunction mapFlowFacets(data, done) {\n  var that = this;\n  var key  = this.spec.facet;\n\n  nest(data, key, function(nested, cb) {\n    var facet = { key: key, value: nested.key };\n    if (nested.key !== 'undefined') { that.facets.push(facet); }\n    mapGroups.call(that, nested.values, cb);\n  }, \n  done);\n}\n\n\nfunction mapGroups(data, done) {\n  var that = this;\n  var key  = this.spec.group;\n\n  nest(data, key, function(nested, cb) {\n    var group = { key: key, value: nested.key };\n    if (nested.key !== 'undefined') { that.group.push(group); }\n    mapGeometries.call(that, nested.values, cb);\n  }, \n  done);\n}\n\n\nfunction mapGeometries(data, done) {\n  var that = this;\n  var key  = this.spec.geometry;\n  \n  nest(data, key, function(nested, cb) {\n    that.geometries.push(nested.values);\n    cb();\n  }, \n  done);\n}","\n// Draw SVG\n// ----------------------------------------------------\n\nGraphic.prototype.draw = function(el, width, height) {\n  if (el)     { this.spec.el = el; }\n  if (width)  { this.spec.width = width; }\n  if (height) { this.spec.height = height; }\n\n  var noDimensions = (!el && (!width && !height));\n  if (noDimensions) { throw Error('An element or height & width must be specified.'); }\n\n  if (this.spec.el) { el = d3.select(this.spec.el); }\n  width = this.spec.width   || parseInt(el.style('width'));\n  height = this.spec.height || parseInt(el.style('height'));\n\n  var svg = this.el.selectAll('svg')\n    .data([1])\n    .enter().append('svg')\n    .attr('width', width)\n    .attr('height', height)\n    .attr('class', 'graphic');\n\n  this.drawFacetY(svg, width, height);\n};\n\n\n// Y facets divide the svg horizontally. Each facet gets an\n// equal share of the canvas.\nGraphic.prototype.drawFacetY = function(svg, width, height) {\n  var facetHeight = height / (this.facetY.length || 1);\n\n  // Even if y facets aren't defined we still want to create\n  // an element for them (to hold x & flow facets). If data\n  // is empty, bind yFacet element to an empty object.\n\n  var data = this.facetY;\n  if (_.isEmpty(data)) { data = [{}]; }\n\n  var facetY = svg.selectAll('g.facetY')\n    .data(data)\n    .enter().append('g')\n    .attr('class', 'facetY')\n    .attr('data-key', function(d) { return d.key; })\n    .attr('data-value', function(d) { return d.value; })\n    .attr('transform', function(d,i) {\n      return 'translate('+ (facetHeight * i) +',0)';\n    });\n\n  this.drawFacetX(facetY, width, facetHeight);\n};\n\n\n// X facets divide each Y facet vertically. Each x facet gets\n// an equal share of each y facet.\nGraphic.prototype.drawFacetX = function(facetY, width, height) {\n  var facetWidth = width / (this.facetX.length || 1);\n\n  var data = this.facetX;\n  if (_.isEmpty(data)) { data = [{}]; }\n\n  var facetX = facetY.selectAll('g.facetX')\n    .data(data)\n    .enter().append('g')\n    .attr('class', 'facetX')\n    .attr('data-key', function(d) { return d.key; })\n    .attr('data-value', function(d) { return d.value; })\n    .attr('transform', function(d,i) {\n      return 'translate(0,'+ (facetWidth * i) +')';\n    });\n\n  this.drawFacetFlow(facetX, facetWidth, height);\n};\n\n\n// Flow facets (elsewhere just called \"facets\") divide up the canvas\n// as evenly as possible.\nGraphic.prototype.drawFacetFlow = function(facetX, width, height) {\n  var numFacets = this.facet.length || 1;\n\n  // To calculate best fit, first we have to determine the ratio\n  // of width:height to use for each facet.\n  var widerThanTall = width/height >=1;\n  var ratio = widerThanTall ? Math.floor(width/height) : 1/Math.floor(height/width);\n\n  // Now that we have the ratio along with the actual dimensions \n  // of the canvas, we can calculate the total number of rows & cols.\n  var numRows = ratio >= 1 ? Math.floor(width/height) : Math.ceil(ratio/numFacets);\n  var numCols = Math.ceil(numFacets/numRows);\n\n  var facetWidth = width/numCols;\n  var facetHeight = height/numRows;\n\n  var data = this.facet;\n  if (_.isEmpty(data)) { data = [{}]; }\n\n  var facetFlow = facetX.selectAll('g.facet')\n    .data(data)\n    .enter().append('g')\n    .attr('class', 'facet')\n    .attr('data-key', function(d) { return d.key; })\n    .attr('data-value', function(d) { return d.value; })\n    .attr('transform', function(d,i) {\n      var colNum = i % ratio;\n      var rowNum = Math.floor(i/ratio);\n      return 'translate('+ (colNum * facetWidth) +','+ (rowNum * facetHeight) +')';\n    });\n\n  this.drawGroup(facetFlow, facetWidth, facetHeight);\n};\n\n\n// Groups organize data points. E.g. each separate line on a line\n// chart is a group of data.\nGraphic.prototype.drawGroup = function(facet, width, height) {\n  var data = this.group;\n  if (_.isEmpty(data)) { data = [{}]; }\n\n  var group = facet.selectAll('g.group')\n    .data(data)\n    .enter().append('g')\n    .attr('class', 'group')\n    .attr('data-key', function(d) { return d.key; })\n    .attr('data-value', function(d) { return d.value; });\n\n  this.drawPointGeometry(group, width, height);\n};\n\n\nGraphic.prototype.drawPointGeometry = function(group, width, height) {\n  var that = this;\n\n  // Users might want to change geometry types without having to \n  // pass in arguments to the functions. Set vars here if undefined.\n  group = group   || d3.selectAll('g.group');\n  width = width   || parseInt(group.style('width'));\n  height = height || parseInt(group.style('height'));\n\n  d3.selectAll(group).each(function(datum, index) {\n    var data = that.geometry[index];\n    var selection = d3.selectAll(this);\n\n    selection.selectAll('circle.point')\n      .data(data)\n      .enter().append('circle')\n      .attr('class', 'point')\n      .attr('r', 2)\n      .attr('cx', 20)\n      .attr('cy', 20)\n  });\n};","\n// Export global\n// ----------------------------------------------------\n// Export as a Node module if applicable. Else\n// attach ggd3 to the global object.\n\nif (isNode) { module.exports = ggd3; }\nelse { this.ggd3 = ggd3; }"],"sourceRoot":"/source/"}