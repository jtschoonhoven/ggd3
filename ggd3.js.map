{"version":3,"sources":["index.js","configure.js","applyData.js","mapData.js","draw.js","export.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"ggd3.js","sourcesContent":["// Configure for Node and the browser.\nvar isNode = false;\nif (typeof module !== 'undefined' && module.exports) {\n  isNode = true;Â \n  this.d3 = require('d3');\n  this._  = require('underscore');\n\n  // Uses jsdom to build HTML server side.\n  document = require('jsdom').jsdom();\n  window = document.parentWindow;\n}\n\nif (!d3 || !_) { throw 'ggd3 requires D3 and Underscore.'; }\n\n\nvar ggd3 = {};\nggd3.VERSION = '0.0.0';\n\n\n// Each chart is an instance of Graphic.\nvar Graphic = function() {\n  this.el = d3.select(document.createElement('div'));\n};\n\n\nggd3.create = function(spec, data) {\n  var graphic = new Graphic();\n  graphic.configure(spec);\n  graphic.applyData(data);\n  graphic.mapData(graphic.data);\n\n  // If the graphic's dimensions were specified\n  // or if they can be retrieved from \"el\", go\n  // ahead and call graphic.draw.\n\n  var el     = graphic.spec.el;\n  var width  = graphic.spec.width;\n  var height = graphic.spec.height;\n\n  var hasDimensions = el || (height && width);\n  if (hasDimensions) { graphic.draw(el, width, height); }\n\n  return graphic;\n};","var defaults = {\n  title: undefined,\n  el: undefined,\n  width: undefined,\n  height: undefined,\n  x: undefined,\n  y: undefined,\n  color: undefined,\n  size: undefined,\n  facet: undefined,\n  facetX: undefined,\n  facetY: undefined,\n  geometry: 'point',\n  floatFacetScaleX: false,\n  floatFacetScaleY: false\n};\n\nGraphic.prototype.configure = function(spec) {\n  this.spec = _.defaults(spec || {}, defaults)\n  return this;\n};","\n// Apply Data\n// ----------------------------------------------------\n// Raw data may be passed in as an array. Or a named\n// dataset may be passed as { key: '', values: [] }.\n\nGraphic.prototype.applyData = function() {\n  var data = [];\n\n  // If one dataset was passed in, assign it to this.data.\n  if (arguments.length === 1) {\n    var dataset = arguments[0] || [];\n    if (_.isArray(dataset))       { this.data = dataset; }\n    else if (_.isObject(dataset)) { this.data = dataset.values; }\n    return this;\n  }\n\n  // If multiple sets were passed in, join them.\n  _.each(arguments, function(dataset, index) {\n    if (_.isArray(dataset)) {\n      _.each(dataset, function(row) { row.dataset = row.dataset || index });\n      data = data.concat(dataset);\n    }\n\n    else if (_.isObject(dataset)) {\n      _.each(dataset.values, function(row) { row.dataset = row.dataset || dataset.key || index });\n      data = data.concat(dataset.values);\n    }\n  });\n\n  this.data = data;\n  return this;\n};","\n// Map Data to Components\n// ----------------------------------------------------\n// Once the graphic has been configured and has had\n// data applied, that data may be mapped to components.\n\nGraphic.prototype.mapData = function() {\n  var that = this;\n\n  var mappings = ['facetY', 'facetX', 'facet', 'group', 'geometry'];\n  var mapping, result;\n\n  // Add an empty array to graphic for each mapping.\n  mappings.forEach(function(mapping) { that[mapping] = []; });\n\n  // Use d3.nest() to perform a GroupBy of the dataset.\n  nest(0, this.data);\n  function nest(mapIndex, data) {\n    var mapping = mappings[mapIndex];\n\n    d3.nest()\n      .key(function(row) { return row[that.spec[mapping]]; })\n      .entries(data)\n      .forEach(function(group, index) {\n        if (mapping === 'geometry') { that.geometry.push(group.values); }\n\n        else { \n          result = { key: that.spec[mapping], value: group.key };\n          if (group.key !== 'undefined') { that[mapping].push(result); }\n          nest(mapIndex+1, group.values);\n        }\n      });   \n  }\n\n  return this;\n};","\n// Draw SVG\n// ----------------------------------------------------\n\nGraphic.prototype.draw = function(el, width, height) {\n  if (el)     { this.spec.el = el; }\n  if (width)  { this.spec.width = width; }\n  if (height) { this.spec.height = height; }\n\n  var noDimensions = (!el && (!width && !height));\n  if (noDimensions) { throw Error('An element or height & width must be specified.'); }\n\n  if (this.spec.el) { el = d3.select(this.spec.el); }\n  width = this.spec.width   || parseInt(el.style('width'));\n  height = this.spec.height || parseInt(el.style('height'));\n\n  var svg = this.el.selectAll('svg')\n    .data([1])\n    .enter().append('svg')\n    .attr('width', width)\n    .attr('height', height)\n    .attr('class', 'graphic');\n\n  this.drawFacetY(svg, width, height);\n};\n\n\n// Y facets divide the svg horizontally. Each facet gets an\n// equal share of the canvas.\nGraphic.prototype.drawFacetY = function(svg, width, height) {\n  var facetHeight = height / (this.facetY.length || 1);\n\n  // Even if y facets aren't defined we still want to create\n  // an element for them (to hold x & flow facets). If data\n  // is empty, bind yFacet element to an empty object.\n\n  var data = this.facetY;\n  if (_.isEmpty(data)) { data = [{}]; }\n\n  var facetY = svg.selectAll('g.facetY')\n    .data(data)\n    .enter().append('g')\n    .attr('class', 'facetY')\n    .attr('data-key', function(d) { return d.key; })\n    .attr('data-value', function(d) { return d.value; })\n    .attr('transform', function(d,i) {\n      return 'translate('+ (facetHeight * i) +',0)';\n    });\n\n  this.drawFacetX(facetY, width, facetHeight);\n};\n\n\n// X facets divide each Y facet vertically. Each x facet gets\n// an equal share of each y facet.\nGraphic.prototype.drawFacetX = function(facetY, width, height) {\n  var facetWidth = width / (this.facetX.length || 1);\n\n  var data = this.facetX;\n  if (_.isEmpty(data)) { data = [{}]; }\n\n  var facetX = facetY.selectAll('g.facetX')\n    .data(data)\n    .enter().append('g')\n    .attr('class', 'facetX')\n    .attr('data-key', function(d) { return d.key; })\n    .attr('data-value', function(d) { return d.value; })\n    .attr('transform', function(d,i) {\n      return 'translate(0,'+ (facetWidth * i) +')';\n    });\n\n  this.drawFacetFlow(facetX, facetWidth, height);\n};\n\n\n// Flow facets (elsewhere just called \"facets\") divide up the canvas\n// as evenly as possible.\nGraphic.prototype.drawFacetFlow = function(facetX, width, height) {\n  var numFacets = this.facet.length || 1;\n\n  // To calculate best fit, first we have to determine the ratio\n  // of width:height to use for each facet.\n  var widerThanTall = width/height >=1;\n  var ratio = widerThanTall ? Math.floor(width/height) : 1/Math.floor(height/width);\n\n  // Now that we have the ratio along with the actual dimensions \n  // of the canvas, we can calculate the total number of rows & cols.\n  var numRows = ratio >= 1 ? Math.floor(width/height) : Math.ceil(ratio/numFacets);\n  var numCols = Math.ceil(numFacets/numRows);\n\n  var facetWidth = width/numCols;\n  var facetHeight = height/numRows;\n\n  var data = this.facet;\n  if (_.isEmpty(data)) { data = [{}]; }\n\n  var facetFlow = facetX.selectAll('g.facet')\n    .data(data)\n    .enter().append('g')\n    .attr('class', 'facet')\n    .attr('data-key', function(d) { return d.key; })\n    .attr('data-value', function(d) { return d.value; })\n    .attr('transform', function(d,i) {\n      var colNum = i % ratio;\n      var rowNum = Math.floor(i/ratio);\n      return 'translate('+ (colNum * facetWidth) +','+ (rowNum * facetHeight) +')';\n    });\n\n  this.drawGroup(facetFlow, facetWidth, facetHeight);\n};\n\n\n// Groups organize data points. E.g. each separate line on a line\n// chart is a group of data.\nGraphic.prototype.drawGroup = function(facet, width, height) {\n  var data = this.group;\n  if (_.isEmpty(data)) { data = [{}]; }\n\n  var group = facet.selectAll('g.group')\n    .data(data)\n    .enter().append('g')\n    .attr('class', 'group')\n    .attr('data-key', function(d) { return d.key; })\n    .attr('data-value', function(d) { return d.value; });\n\n  this.drawPointGeometry(group, width, height);\n};\n\n\nGraphic.prototype.drawPointGeometry = function(group, width, height) {\n  var that = this;\n\n  // Users might want to change geometry types without having to \n  // pass in arguments to the functions. Set vars here if undefined.\n  group = group   || d3.selectAll('g.group');\n  width = width   || parseInt(group.style('width'));\n  height = height || parseInt(group.style('height'));\n\n  d3.selectAll(group).each(function(datum, index) {\n    var data = that.geometry[index];\n    var selection = d3.selectAll(this);\n\n    selection.selectAll('circle.point')\n      .data(data)\n      .enter().append('circle')\n      .attr('class', 'point')\n      .attr('r', 2)\n      .attr('cx', 20)\n      .attr('cy', 20)\n  });\n};","\n// Export global\n// ----------------------------------------------------\n// Export as a Node module if applicable. Else\n// attach ggd3 to the global object.\n\nif (isNode) { module.exports = ggd3; }\nelse { this.ggd3 = ggd3; }"],"sourceRoot":"/source/"}